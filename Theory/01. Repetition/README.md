# Вспомнить что такое БД, СУБД, SQL

- DDL - data definition language (Create, Alter, Drop)
- DML - data manipulation language (Select, Insert, Update, Delete)
- DCL - data control language (Grant, Revoke)
- TCL - transaction control language (Commit, Rollback, Savepoint)

**Первичный ключ** - используется для уникальной идентификации объектов.

**Внешний ключ** - ограничение **целостности**.

**Целостность** – правильность данных в любой момент времени.

Цель может быть достигнута в определенных пределах. Нельзя, что число 3 (день недели) в реальности должно быть равно 2. Однако число 9 явно будет ошибочным. И СУБД может не допустить добавление его в БД, но для этого надо указать, что ОДЗ в атрибуте равна (1,2,3,4,5,6,7), т.е. создать домен.

На базу накладываются ограничения целостности — защита от неверных изменений. Существует несколько видов целостности:

 1. По сущностям (декларативная)

 2. По ссылкам (ссылочная)

 3. Определяемая пользователем (семантическая)

 4. Физическая (целостность файлов ОС)

Декларативная целостность – тип данных, размер, NOT  NULL, домен, первичный, уникальный ключ.

Ссылочная целостность – внешний ключ. Есть 3 типа: Каскадное удаление – при удалении студента, удаляется и все его связанные данные. Ограничение (disallow) – удалить тех, у кого нет хобби, иначе удаление не произойдёт. Установка (set  null  on  delete) – если удаляется студент, все связанные данные будут null.

**Домен** - ОДЗ (область допустимых значений). В oracle - CHECK.

Атрибуты, Кортежи, Отношения.

Для внешнего ключа существуют 3 разновидности связи - один ко многим, один к одному, многие ко многим.

## DDL

### Оператор CREATE

#### Создание таблицы

[Подробнее](https://www.postgresql.org/docs/current/sql-createtable.html)

Оператор CREATE служит для создания любого типа объектов, из которых состоит база данных, в том числе таблиц.

Синтаксис команды создания таблицы:

```sql
CREATE TABLE _имя_таблицы_(
_поле1 тип1_ [_ограничения_],
[_поле2 тип2_ [_ограничения_],
…]);
```

Возможные ограничения в таблицах:

- NOT NULL – значение атрибута должно быть определено (опция NOT  NULL);
- UNIQUE – значения атрибутов являются уникальными (уникальный ключ);
- PRIMARY KEY – атрибут является первичным ключом (первичный ключ);
- CHECK – определяет условие, которому должны удовлетворять значения атрибута (домен);
- DEFAULT – присвоение значений «по умолчанию» для атрибутов.

Используя приведенный выше синтаксис, вместе с созданием таблицы можно вместе с атрибутами таблицы сразу же задать и ограничения декларативной и ссылочной целостности, но только в том случае, если они касаются только одного конкретного атрибута. Если же первичный, уникальный или вторичный ключ должны быть составными, для их создания нужно применять команду ALTER  TABLE.

Например, для создания таблицы student достаточно выполнить следующую команду:

```sql
CREATE TABLE student (
id SERIAL PRIMARY KEY,
name VARCHAR(100),
surname VARCHAR(100),
birth_date TIMESTAMPTZ);
```

#### Создание копии таблицы

Иногда необходимо создать таблицу в точности или частично по структуре и содержанию копирующую какую-либо из существующих таблиц. В этом случае используется следующий синтаксис:

```sql
CREATE TABLE имя_таблицы AS оператор SELECT
```

Например, для того чтобы создать копию таблицы student можно выполнить следующую команду:

```sql
CREATE TABLE student_copy AS SELECT * FROM student;
```

### Оператор ALTER

[Подробнее](https://www.postgresql.org/docs/current/sql-altertable.html)

Оператор ALTER служит для изменения структуры любых объектов, из которых состоит база данных. В зависимости от типа объекта, изменяются и параметры команды ALTER.

#### Добавление атрибута таблицы

Для добавления атрибута к таблице применяется следующий синтаксис:

```sql
ALTER TABLE имя_таблиц_ ADD поле тип [ограничения];
```

Например, для добавления к таблице student  поля n_group  можно выполнить следующую команду:

```sql
ALTER TABLE student ADD n_group  NUMBER(4);
```

#### Удаление атрибута таблицы

Для удаления атрибута таблицы применяется следующий синтаксис:

```sql
ALTER TABLE имя_таблицы DROP COLUMN поле;
```

#### Изменение типа атрибута, размера типа и наличия ограничения NOT NULL

Для изменения типа данных атрибута, размера типа данных или наличия опции NOT  NULL используется следующие синтаксис:

```sql
ALTER  TABLE  имя_таблицы  MODIFY  поле  тип [ограничения];
```

При изменении типов данных и размеров типов данных атрибутов следует соблюдать осторожность. Дело в том, что при «сужении» области допустимых значений, который может принимать атрибут, могут быть утеряны («обрезаны») данные, выходящие за пределы новой области допустимых значений.

#### Создание первичного ключа

Для создания первичного ключа используется следующий синтаксис:

```sql
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения PRIMARY  KEY(список_полей);
```

Например, для создания первичного ключа таблицы student можно выполнить следующую команду:

```sql
ALTER TABLE student ADD CONSTRAINT Students_PK PRIMARY  KEY(id);
```

Если создаваемый первичный ключ является составным, то есть состоит из нескольких атрибутов, атрибуты перечисляются через запятую.

#### Создание уникального ключа

Для создания уникального ключа используется следующий синтаксис:

```sql
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения UNIQUE(_список_полей_);
```

Например, для создания уникального ключа в таблице student, гарантирующего уникальность значений в атрибуте Comments, можно выполнить следующую команду:

```sql
ALTER TABLE student ADD CONSTRAINT Students_Comm_uk UNIQUE (Comment);
```

#### Создание домена

Для создания домена используется следующий синтаксис:

```sql
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения CHECK(_условное_выражение_);
```

При наличии домена в таблице, каждый раз при изменении или добавлении значений в атрибуты, затрагиваемые условным выражением, СУБД будет проверять новое значение атрибутов на удовлетворение указанному выражению. Новое значение будет присвоено атрибуту только в том случае, если значение удовлетворяет указанному условию. При составлении условных выражений можно использовать логические операции >, <, >=, <=, <>, =, функции IN (проверка вхождения в множество), BETWEEN (проверка вхождения в диапазон), LIKE (проверка на удовлетворению шаблону). Кроме того, несколько условных выражений можно комбинировать при помощи логических операторов AND, OR и NOT.

```sql
ALTER TABLE student ADD CONSTRAINT Students_Ngr_check CHECK(n_group >= 0);
```

#### Создание внешнего ключа

Для добавления внешнего ключа используется следующий синтаксис:

```sql
ALTER  TABLE  имя_подчиненной_таблицы
ADD  CONSTRAINT  имя_ограничения
FOREIGN  KEY(список_полей_подчиненной_таблицы)
REFERENCES  имя_главной_таблицы(список_полей_главной_таблицы)
[ON UPDATE CASCADE | SET NULL | SET DEFAULT | NO ACTION]
[ON UPDATE CASCADE | SET NULL | SET DEFAULT | NO ACTION];
```

Параметры _ON_ _UPDATE_ и _ON_ _DELETE_ указываются при необходимости осуществлять каскадные действия при, соответственно, изменении или удалении значений атрибутов первичного ключа главной таблицы. При попытке изменения значения атрибута, входящего в состав первичного ключа, или удаления строки, на которую ссылаются строки из подчиненных таблиц, СУБД принимает решение либо о выполнении одного из каскадных действий, либо о запрещении SQL-оператора, изменяющего или удаляющего строку в главной таблице.

Если параметры ON  UPDATE или ON  DELETE равны NO  ACTION или они не указаны совсем, СУБД запретит выполнение SQL-оператора, нарушающего ссылочную целостность.

Если после параметров ON  UPDATE или ON  DELETE стоит значение CASCADE, то произойдет каскадное изменение или удаление строк в подчиненных таблицах. Иными словами, при удалении строки из главной таблицы, будут удалены все строки в подчиненных таблицах, которые ссылались на удаляемую строку. При изменении значения первичного ключа главной таблицы и наличии параметра ON  UPDATE со значением CASCADE все значения внешних  ключей, ссылающихся на изменяемый атрибут, также изменят свое значение.

Использовать значение CASCADE параметров ON  UPDATE и ON  DELETE следует с особой осторожностью, поскольку одна ошибочная команда, например, удаления строки в одной из таблиц может повлечь за собой необратимые последствия, которые могут привести к полной неработоспособности приложений базы данных. Если все-таки необходимо выполнять каскадное изменение или удаление данных в подчиненных таблицах, рекомендуется, по возможности, реализовывать это посредством хранимых процедур.

Указание значения SET  NULL для параметров ON  UPDATE или ON  DELETE приведет к тому, что значения атрибутов внешних ключей, ссылающихся на изменяемое значение первичного ключа, установится в NULL.

Указание значения SET  DEFAULT для параметров ON  UPDATE или ON  DELETE приведет к тому, что значения атрибутов внешних ключей, ссылающихся на изменяемое значение первичного ключа, примут значение по умолчанию, заданное при создании таблицы.

Пример создания внешнего ключа, связывающего таблицы  Students_Hobby  и student можно выполнить следующую команду:

```sql
ALTER TABLE Students_Hobby ADD CONSTRAINT Students_Hobby_fk FOREIGN KEY(id) REFERENCES student(id);
```

#### Удаление ограничений целостности

Для удаления ограничения целостности (первичного ключа, уникального ключа или внешнего ключа) применяется следующий синтаксис:

```sql
ALTER TABLE имя_таблицы DROP CONSTRAINT имя_ограничения;
```

Например, для удаления внешнего ключа связывающего таблицы Students_Hobby  и student можно выполнить следующую команду:

```sql
ALTER TABLE Dealers DROP CONSTRAINT Students_Hobby_fk;
```

### Оператор DROP

Оператор DROP служит для удаления объектов из базы данных. Синтаксис удаления любого типа объекта из базы данных, в том числе таблицы, выглядит следующим образом:

DROP  _тип объекта имя объекта_;

В данном случае таблица успешно удалится только в том случае, если на нее не ссылаются внешний ключи других таблиц. В том случае, если внешние ключи существуют, но удалить таблицу все-таки необходимо, можно, либо сначала удалить все внешние ключи, ссылающиеся на удаляемую таблицу, после чего удалить таблицу, либо используя параметр CASCADE  CONSTRAINTS:

```sql
DROP TABLE Имя_Таблицы CASCADE CONSTRAINTS;
```

В последнем случае, если внешние ключи, ссылающиеся на удаляемую таблицу, существуют, они будут удалены без изменений в полях внешних ключей подчиненных таблиц, даже если при создании внешних ключей были указаны параметры, задающие каскадные действия.

## DML

### Оператор выбора SELECT

Все запросы на получение практически любого количества данных из одной или нескольких таблиц выполняются с помощью единственного предложения SELECT. Синтаксис оператора SELECT имеет следующий вид:

```sql
SELECT [ALL | DISTINCT] <список полей> | *
FROM <список таблиц>
[WHERE <условие фильтрации строк>]
[GROUP BY <условия группировки строк>]
[HAVING <условие фильтрации групп>]
[ORDER BY <условие сортировки результата запроса>]
```

Обязательными среди всех указанных параметров оператора SELECT являются параметры SELECT и FROM. Результатом выполнения оператора SELECT является набор данных (временная таблица), который затем либо передается пользователю, запросившему данные, либо используется как источник данных для другого оператора SELECT в качестве подзапроса. Представляет исторический интерес тот факт, что именно возможность включения одного предложения SELECT внутрь другого послужила мотивировкой использования прилагательного «структурированный» в названии языка SQL.

### Запросы с использованием единственной таблицы

#### Выборка без использования параметра WHERE

Выборка данных без использования параметра WHERE с использованием единственной таблицы является наиболее простой формой использования оператора SELECT.

**Выборка всей информации из таблицы**

```sql
SELECT список_всех_полей_таблицы | * FROM имя_таблицы;
```

Данная форма оператора SELECT используется, когда не нужно выполнять ни горизонтальную, ни вертикальную фильтрации. Символ «*» заменяет необходимость указания всех полей таблицы. Например:

```sql
SELECT * 
FROM  student;
```

**Вертикальная фильтрация с указанием порядка вывода атрибутов**

```sql
SELECT поле1[, поле2, …] FROM имя_таблицы;
```

В результирующий набор записей попадут данные только из указанных полей таблицы, причем в том же самом порядке, в каком они указаны в операторе SELECT. Например:

-- вывод неполной информации о студентах

```sql
SELECT id, name
FROM student;
```

**Исключение дубликатов**

При использовании в операторе SELECT вертикальной фильтрации строк таблицы может сложиться ситуация, когда набор записей будет включать дубликаты – записи, значения полей которых полностью совпадают. Для исключения дубликатов из результирующего набора записей используют параметр DISTINCT, который указывают сразу после ключевого слова SELECT. Например:

-- вывод различных фамилий

```sql
SELECT DISTINCT surname 
FROM student;
```

**Выборка вычисляемых значений**

Наравне с перечнем полей таблиц после ключевого слова SELECT можно указывать выражения, вычисляемые на основе полей таблиц, либо встроенных функций СУБД.

Обычно синонимы используются либо для именования результатов выражений, либо для замены полей таблицы более подходящими в конкретной ситуации названиями.

**Сортировка результирующего набора данных**

Строки в таблицах базы данных изначально хранятся в том порядке, в каком их туда поместили. Иногда СУБД по своему усмотрению может менять внутреннюю организацию хранения данных. По этой причине никогда не стоит надеяться, что оператор SELECT вернет отсортированный набор данных, даже в том случае, если записи заносились в таблицу в соответствии с возрастанием или убыванием значений в определенных полях. Для сортировки результирующего набора данных используется параметр ORDER  BY оператора SELECT. Например:

```sql
SELECT * FROM student 
ORDER BY surname, name;
```

Если после параметра ORDER  BY указано более одного поля, сортировка сначала осуществляется по первому полю, потом, в случае наличия одинаковых значений, по второму и т.д. В приведенном примере результирующий набор данных сначала будет отсортирован по значениям поля Name, и в том случае, если в каких-то строках имена некоторых дилеров совпадут, эти строки отдельно будут отсортированы по значению поля Procent.

По умолчанию (неявно) сортировка всегда происходит по возрастанию. Но способ сортировки можно задать явно, указав после соответствующего поля параметр ASC или DESC для сортировки по возрастанию или убыванию соответственно. Например:

```sql
SELECT * FROM student 
ORDER BY surname, name DESC;
```

#### Выборка с использованием параметра WHERE

Параметр WHERE служит для реализации реляционной операции горизонтальной фильтрации, то есть отбора кортежей, или строк, удовлетворяющих определенному условию. Условие может быть составлено с использованием следующих конструкций:

- операторы сравнения: =, < , > , <= , >= , <>;
- булевы  операторы: AND, OR, NOT;
- оператор проверки на вхождение в множество: IN;
- оператор проверки на вхождение в диапазон: BETWEEN;
- оператор проверки на существование: EXISTS;
- оператор проверки удовлетворению шаблону (только для символьных полей): LIKE;
- операторы сравнения с NULL: IS NULL,  IS NOT NULL;
- агрегатные функции: COUNT, SUM, AVG, MAX, MIN;
- константы и выражения;
- подзапросы.

Следует быть осторожными при использовании булевых операторов, поскольку существует приоритет AND над OR (сначала выполняются все операции AND и только после этого операции OR). Для получения желаемого результата WHERE условия должны быть введены в правильном порядке, который можно организовать введением скобок.

При обработке условия числа сравниваются алгебраически – отрицательные числа считаются меньшими, чем положительные, независимо от их абсолютной величины. Строки символов сравниваются в соответствии с их представлением в коде, используемом в конкретной СУБД, например, в коде ASCII. Если сравниваются две строки символов, имеющих разные длины, более короткая строка дополняется справа пробелами для того, чтобы они имели одинаковую длину перед осуществлением сравнения.

**Использование операторов сравнения**

В параметре WHERE оператора SELECT для отбора нужных строк таблицы можно использовать операторы сравнения = (равно), <> (не равно), < (меньше), <= (меньше или равно), > (больше), > = (больше или равно), которые могут предваряться оператором NOT, создавая, например, отношения «не меньше» и «не больше».

```sql
SELECT name FROM hobby 
WHERE risk <=5;
```

-- то же самое с применением оператора NOT

```sql
SELECT name FROM hobby 
WHERE NOT risk >5;
```

Возможность использования нескольких условий, соединенных логическими операторами AND, OR, AND  NOT и OR  NOT, позволяет осуществить более детальный отбор строк.

**Использование BETWEEN**

С помощью оператора BETWEEN можно отобрать строки, в которых значение какого-либо столбца находятся в заданном диапазоне.

При помощи сочетания операторов NOT и BETWEEN можно отобрать строки, в которых значение какого-либо столбца не находится в заданном диапазоне. Например:

```sql
SELECT name FROM hobby 
WHERE risk NOT BETWEEN 5 and 8;
```

Использование оператора BETWEEN возможно не только по отношению к полям числового типа, он применим также к полям строкового типа и датам.

**Использование IN**

Оператор IN используется для проверки вхождения значения какого-либо столбца в множество. Например:

```sql
SELECT n_group FROM student
WHERE n_group IN (11, 12, 13);
```

Рассмотренная форма IN является в действительности просто краткой записью последовательности отдельных сравнений, соединенных операторами OR.

В сочетании с оператором IN можно также использовать NOT для отбора строк, в которых значение какого-либо столбца наоборот не входит в множество. Например:

```sql
SELECT n_group FROM student
WHERE n_group NOT IN (11, 12, 13);
```

**Использование** **LIKE**

Оператор LIKE используется для отбора строк, в которых значение какого-либо удовлетворяет определенному шаблону. Данный оператор применяется только к символьным полям. Обычная форма _имя_столбца_LIKE_текстовая_константа_ для столбца символьного типа позволяет отыскать все значения указанного столбца, соответствующие шаблону, заданному _текстовой_константой_. Символы этой константы интерпретируются следующим образом:

- символ _ (подчеркивание) – заменяет любой одиночный символ;
- символ % (процент) – заменяет любую последовательность из любого количества символов, в том числе нулевого;
- все другие символы означают просто сами себя.

Примеры:

-- отбор информации о студентах,
-- фамилии которых начинаются с заглавной буквы «О»
-- и  заканчивающихся  на «ов»

```sql
SELECT * 
FROM student 
WHERE surname LIKE ‘O%ов’;
```

Оператор LIKE также можно сочетать с NOT для получения строк, значения определенных столбцов которых не удовлетворяют указанному шаблону.

**Сравнение с неопределенным значением NULL**

Для отбора строк таблицы, значения атрибутов которых необходимо сравнивать на равенство или неравенство с NULL-значением, используют операторы IS  NULL и IS  NOT  NULL соответственно. Использование операторов «=» или «<>» не вызовет ошибки, но и не позволит достичь необходимого результата. Например:

-- отбор студентов, у которых не указан номер телефона

```sql
SELECT * 
FROM student 
WHERE phone IS NULL;
```

В СУБД ORACLE есть некоторые отличия реализации NULL-значений по сравнению со стандартом ANSI SQL. Согласно ANSI все типы данных должны поддерживать неопределенные или NULL-значения. СУБД ORACLE в полной мере поддерживает это правило для всех типов, за исключением символьных. Для любых символьных данных пустая строка интерпретируется как NULL, например два оператора ORACLE SQL полностью идентичны и вставят в поле Comments значения NULL, а не пустые строки:

В ORACLE вообще нельзя вставить пустую строку – она всегда будет рассматриваться как NULL.

## DCL

```sql
Grant [privileges] on [table] to [schema]
Example: Grant select on student to user
Revoke [privileges] on [table] from [schema]

Select * from [schema].[table]
```

Просмотр всех полномочий, предоставленных/полученных:

```sql
SELECT * FROM USER_TAB_PRIVS;
```

## TCL

[Материал прошлого семестра](https://github.com/RyabovNick/databasecourse_p1/blob/master/Theory/2_SQL/TCL.md)

[Подробнее](https://www.postgresql.org/docs/current/tutorial-transactions.html)

## Views

Идея представления (_View_) состоит в следующем: определить запрос, который предполагается использовать достаточно часто, сохранить его в базе данных в виде объекта ORACLE и разрешить пользователям обращаться к нему по имени, как к обычной таблице. Когда пользователь выбирает данные из представления, СУБД выполняет соответствующий запрос, организует результаты так, как определено в представлении, и выдает их пользователю. Для пользователя представление выглядит как таблица, из которой поступают данные. Однако на самом деле данные поступают через представление, из одного или нескольких других источников – исходных таблиц или других представлений.

Запрос, непосредственное выполнение которого можно заменить использованием представлений, может быть какой угодно сложности. В сущности, это и есть одно из назначений использования представлений – скрытие сложности запросов и структуры данных от пользователей.

Кроме того, представления обеспечивают дополнительный уровень безопасности базы данных, поскольку позволяют ограничивать диапазон строк и столбцов, возвращаемых пользователям. Если нужно скрыть от пользователей определенные столбцы или строки той или иной таблицы (таблиц), эти строки или столбцы достаточно исключить из результатов запроса при помощи операций горизонтальной и вертикальной фильтрации, тем самым, исключив и из представления. Если после этого закрыть доступ к исходным таблицам, из которых при помощи запроса выбираются данные, то для пользователей, имеющих доступ только к представлению, скрытые столбцы или строки просто не будут существовать.

Наконец, представления могут сделать работу с таблицами более удобной. При создании представлений можно как угодно называть имена столбцов, а также изменять порядок их отображения. Эта возможность часто используется тогда, когда необходимо подвести под некий общий стандарт, действующий внутри той или иной организации или рабочей группе, имена всех столбцов таким образом, чтобы они были понятным определенной категории пользователей.

### Создание и удаление представлений

Для создания представлений используется следующий синтаксис:

```sql
CREATE [OR REPLACE] VIEW имя_представления AS
оператор SELECT 
[WITH CHECK OPTION];
```

Использование необязательного параметра OR  REPLACE позволяет заменить уже существующее представление с таким же именем новым. Если существующего представления с таким именем нет, то этот параметр игнорируется.

Примеры создания представлений:

-- создание представления, содержащего все поля таблицы

-- student за исключением поля phone (скрытие данных)

```sql
CREATE OR REPLACE VIEW Students_V1 AS
SELECT id, surname, name, n_group,B_Date FROM student;
```

Удаление представлений, как и всех других объектов базы данных, осуществляется при помощи оператора DROP  по имени  представления, например:

```sql
DROP  VIEW  Students_V1;
```

### Операции выборки из представлений

Для пользователя выборка данных из представления ничем не отличается от выборки данных из таблицы. Иногда пользователи и не догадываются, пользуются они реальной таблицей или представлением. Выборка данных из представлений осуществляется так же, как и из таблиц – при помощи оператора SELECT, например:

-- выборка всей информации обо всех студентах

-- за исключением номера телефона(его мы изначально не включили в представление) и даты рождения, отсортированной по номеру группы.

```sql
SELECT id, surname, name, n_group FROM Students_V1
ORDER  BY  n_group;
```

### Обновляемые представления

Если к представлению можно применить операторы обновления (INSERT, UPDATE или DELETE), то представление является _обновляемым_ (updateble), иначе оно является _читаемым_ (read-only).

Ниже приведены критерии того, является ли представление обновляемым в SQL:

- оно базируется на одной таблице;
- оно должно включать первичный ключ таблицы;
- оно не должно включать полей, полученных в результате применения функций агрегирования;
- оно не может содержать спецификации DISTINCT;
- оно не должно использовать GROUP BY или HAVING;
- оно не должно использовать подзапросы;
- оно может быть определено на другом представлении, но это представление должно быть обновляемым;
- оно не может содержать константы, строки или выражения в списке выбираемых выходных полей;
- для INSERT оно должно включать поля из таблицы, которые имеют ограничения NOT NULL.

Для обновляемых представлений применимы любые операторы обновления, которые при выполнении по отношению к представлению транслируются на исходную таблицу, на основе которой было создано представление. Однако это правило на первый взгляд не согласуется с функцией представлений по защите данных, описанной ранее. Действительно, если представить, что при помощи представления были скрыты столбцы или строки, но пользователь знает об их существовании, он может выполнить операции обновления данных, затрагивающие скрытую в представлении информацию.

Для предотвращения описанной ситуации применяется параметр WITH  CHECK  OPTION, который может указываться при создании обновляемых представлений после оператора SELECT. При наличии этого параметра СУБД предотвращает операции обновления данных, если они нарушают условия горизонтальной или вертикальной фильтрации, определенные в предложении в операторе SELECT:

-- создание обновляемого представления с защитой от
-- изменений  скрытого  столбца

```sql
CREATE OR REPLACE VIEW V2 AS
SELECT id, surname, name, n_group FROM Students_V1
WITH CHECK OPTION;
```

## Нормальные формы

Нормальные формы или нормализация. Цель - избавиться от избыточности в отношениях.

Избыточность — это такое состояние, при котором в таблицах присутствуют лишние данные.

структура отношений является неоптимальной по многим причинам:

1) данные в таблице являются избыточными. Например, адрес одной и той же фирмы повторяется несколько раз. Если таблица будет большой, то из-за избыточных данных нам потребуется много места на хранение, а производительность работы с таблицей упадет;

2) очень легко ошибиться, указав разный адрес (или адрес по разному для одной и той же фирмы)

3) при изменении, к примеру, адреса для фирмы нам потребуется этот адрес поменять во всех записях для данной фирмы.

Кроме того, проблема с нашей таблицей заключается в том, что разнородные данные в столбце "конт. лица" слиты в единое целое. Один из принципов работы с базами данных заключается в том, что обычно очень просто свести в результате запроса вместе данные из разных столбцов, и очень сложно - произвести дальнейшую детализацию, то есть выделить, к примеру, из последнего столбца телефон.

Существуют 6 нормальных форм, но рассматривать мы будем 3, они же и обычно используются на практике.

**1-ая нормальная форма:**

Отношение находится в первой нормальной форме (сокращённо 1НФ), если все его атрибуты атомарны, то есть если ни один из его атрибутов нельзя разделить на более простые атрибуты, которые соответствуют каким-то другим свойствам описываемой сущности.

Т.е. каждый атрибут отношения должен хранить одно-единственное значение и не являться ни множеством, ни списком.

На практике часто бывает очень сложно определить, когда атрибут является атомарным, а когда нет - все зависит от того, как он будет использоваться. Вполне может быть, что для разных пользователей потребуется разная степень дробности атрибутов. Здесь необходимо помнить, что объединять данные из базы легко, а дробить их после занесения информации - сложно.

**2-ая нормальная форма:**

Схема отношения R находится во 2НФ относительно множества функциональных зависимостей F, если она находится в 1НФ и каждый неключевой атрибут полностью зависит от каждого ключа для R.

Можно дать его и более понятным языком: отношение находится во второй нормальной форме, если оно находится в первой нормальной форме и при этом все неключевые атрибуты зависят только от ключа целиком, а не какой-то его части.

| **Код поставщика** | **Город** | **Статус города** | **Код товара** | **Количество** |
|--|--|--|--|--|
| 1 | Москва | 20 | 1 | 300 |
| 1 | Москва | 20 | 2 | 400 |
| 1 | Москва | 20 | 3 | 100 |
| 2 | Ярославль | 10 | 4 | 200 |
| 3 | Ставрополь | 30 | 5 | 300 |
| 3 | Ставрополь | 30 | 6 | 400 |
| 4 | Псков | 15 | 7 | 100 |

Заранее известно, что в этом отношении содержатся следующие функциональные зависимости:  
{ {Код поставщика, Код товара} -> { Количество},  
{Код поставщика} -> {Город},  
{Код поставщика} -> {Статус},  
{Город} -> {Статус} }  
  
Первичный ключ в отношении: {Код поставщика, Код товара}.

Очевидно, что отношение обладает избыточностью: оно описывает две сущности — поставку и поставщика. В связи с этим возникают следующие аномалии:  

- Аномалия вставки. В отношение нельзя добавить информацию о поставщике, который ещё не поставил ни одного товара.
- Аномалия удаления. Если от поставщика была только одна поставка, то при удалении информации о ней будет удалена и вся информация о поставщике.
- Аномалия обновления. Если необходимо изменить какую-либо информацию о поставщике (например, поставщик переехал в другой город), то придётся изменять значения атрибутов во всех записях о поставках от него.

Физический смысл избыточности исходного отношения заключается в том, что оно описывает _не одну_ сущность, а _две_ — _поставку_ и _поставщика_.

**3-ая нормальная форма:**

Схема отношения находится в третьей нормальной форме относительно множества функциональных зависимостей F, если она находится в первой нормальной форме и ни один из непервичных атрибутов в R не является транзитивно зависимым от ключа для R.

Иначе, чтобы привести отношение к третьей нормальной форме, необходимо устранить функциональные зависимости между неключевыми атрибутами отношения. То есть данные, хранимые в таблице, должны зависеть только от ключа.

**1НФ**

Не находится в 1 НФ:

|Фирма| Модели |
|--|--|
| BMW | M5,M1 |
| Nissan|GT-R|

Чтобы находилась в 1НФ:

|Фирма| Модели |
|--|--|
| BMW | M5 |
| BMW | M1 |
| Nissan | GT-R |

**2НФ**

Не находится в 2НФ:

| **Модель** | **Фирма** | **Цена** | **Скидка** |
|--------------|--------------|---------------|--------------|
| M5 | BMW | 5500000 | 5% |
| X5M | BMW | 6000000 | 5% |
| M1 | BMW | 2500000 | 5% |
| GT-R | Nissan | 5000000 | 10% |

Чтобы находилась во 2НФ:

|    **Модель**    |    **Фирма**     |    **Цена**       |
|--------------|--------------|---------------|
|    M5        |    BMW       |    5500000    |
|    X5M       |    BMW       |    6000000    |
|    M1        |    BMW       |    2500000    |
|    GT-R      |    Nissan    |    5000000    |

| Фирма | Скидка |
|--------------|--------------|
| BMW | 5% |
| Nissan | 10% |

**3НФ**

|    Модель    |    Магазин       |    Телефон     |
|--------------|------------------|----------------|
|    BMW       |    Риал-авто     |    87-33-98    |
|    Audi      |    Риал-авто     |    87-33-98    |
|    Nissan    |    Некст-Авто    |    94-54-12    |

Модель – Магазин – Телефон.
Модель – Магазин, Магазин – Телефон.
Модель – Телефон – это транзитивная зависимость. А-Б Б-С =- А-С

## Групповые функции. Соединение таблиц

### Агрегирование данных

#### _Групповые функции_

В большинстве современных СУБД есть возможность использовать так называемые групповые функции (group functions), позволяющие анализировать сразу группы записей. Под группой записей понимается любой набор записей, имеющих что-то общее – например, записи, относящиеся к одному товару, одному отделу или одному временному интервалу. В операторе SELECT при помощи параметра GROUP BY можно определить состав групп, после чего при помощи групповых функций подсчитать количество записей, вошедших в группу, подсчитать итоговую сумму, а также минимальное, максимальное или среднее значение для каждой группы. Если параметр GROUP BY в запросе не указан, то группой записей считается все строки интересующей таблицы.

**COUNT**

Функция возвращает количество записей в группе. Возможно три варианта использования функции COUNT:

COUNT(*) – подсчет количества записей в группе;

COUNT(поле) – подсчет количества отличных от NULL значений в указанном поле записей группы;

COUNT(DISTINCT поле) – подсчет количества уникальных отличных от NULL значений в указанном поле записей группы.

Примеры использования функции COUNT:

-- подсчет количества строк в таблице student

SELECT COUNT(*) FROM Student s;

-- подсчет количества всех различных фамилий студентов

SELECT COUNT(DISTINCT L_name) FROM student;

**SUM**

Функция SUM возвращает суммарное значение для группы.

-- подсчет суммарного значения риска

```sql
SELECT  SUM(risk) FROM  hobby;
```

**MAX**

Функция MAX возвращает максимальное значение для группы.

-- подсчет максимальной даты рождения среди студентов, т. е. поиск самого молодого студента

```sql
SELECT MAX(birth_date) FROM student;
```

**MIN**

Функция MIN возвращает минимальное значение для группы.

поиск самого “старого” студента

```sql
SELECT MIN(birth_date) FROM student;
```

**AVG**

Функция AVG возвращает среднее значение для группы.

-- подсчет средней степени риска для хобби, названия которых заканчиваются на «ов»

```sql
SELECT AVG(risk) FROM hobby WHERE name Like ‘%ов’;
```

#### Использование параметров GROUP BY и HAVING

В предыдущих примерах в качестве группы рассматривался весь набор записей, полученный в результате выполнения запроса. При помощи параметра GROUP  BY оператора SELECT можно указать способ разбиения полученного в результате выполнения запроса набора записей на группы. В параметре GROUP  BY задается столбец (или столбцы), по значениям которого будет производиться группировка. При выполнении оператора SELECT, в котором присутствует параметр GROUP  BY, СУБД проанализирует значение указанного столбца во всех строках, отобранных в результате выполнения запроса. Все строки, где значение указанного в параметре GROUP  BY столбца одно и тоже, попадут в одну группу. После этого для каждой из групп будет вычислена указанная в параметре SELECT групповая функция. Например:

-- вывод номеров групп и количества студентов в  каждой группе

```sql
SELECT n_group, COUNT(n_group) as s_count
FROM student
GROUP BY n_group
ORDER BY n_group DESC;
```

В данном запросе СУБД сначала выделит группы записей, относящиеся к разным группам  (в зависимости от значения столбца n_group) и  для каждой получившейся группы посчитает количество записей.

Параметр HAVING оператора SELECT используется для исключения групп из результирующего набора записей на основе результатов выполнения групповых функций. После параметра HAVING также как и после параметра WHERE указывается условие фильтрации, но в отличие от параметра WHERE, условия которого используются для фильтрации отдельных строк, условия, указанные в параметре HAVING используются для фильтрации целых групп. Например:

-- отбор групп, в которых количество студентов более 12.

```sql
SELECT  n_group, COUNT(n_group) as s_count
FROM student
GROUP BY n_group
HAVING  COUNT(n_group) > 12;
```

### Запросы с использованием нескольких таблиц

Базы данных – это множество взаимосвязанных сущностей или отношений (таблиц) в терминологии реляционных СУБД. При проектировании стремятся создавать таблицы, в каждой из которых содержалась бы информация об одном типе сущностей. Это облегчает модификацию базы данных и поддержание ее целостности. Но такой подход тяжело усваивается начинающими проектировщиками и пользователями баз данных, которые пытаются привязать проект к будущим приложениям и так организовать таблицы, чтобы в каждой из них хранилось все необходимое для реализации возможных запросов.

Даже при отсутствии средств одновременного доступа ко многим таблицам нежелателен проект, в котором информация о многих типах сущностей перемешана в одной таблице. SQL же обладает великолепным механизмом для одновременной или последовательной обработки данных из нескольких взаимосвязанных таблиц. В нем реализованы возможности «соединять» или «объединять» несколько таблиц и так называемые «вложенные подзапросы».

#### Запросы с использованием соединений

**Декартово произведение таблиц**

Соединения – это подмножества декартова произведения. Так как декартово произведение N таблиц – это таблица, содержащая все возможные строки R, такие, что R является сцеплением какой-либо строки из первой таблицы, строки из второй таблицы, ... и строки из N-й таблицы, то осталось лишь выяснить, можно ли с помощью SELECT получить декартово произведение. Для получения декартова произведения нескольких таблиц надо указать в параметре FROM перечень перемножаемых таблиц, а во фразе SELECT – все их столбцы.

Так, для получения декартова произведения таблиц student и student_hobby, необходимо выполнить запрос:

```sql
SELECT student.*, student_hobby.*
FROM student, student_hobby;
```

В зависимости от количества строк, содержащихся в обеих таблицах, результирующий набор записей будет содержать количество строк, равно N*M, где N – количество строк в таблице student, а M – количество строк в таблице student_hobby. При выполнении декартово произведения над большим количеством таблиц, количество получившихся строк еще более возрастет. Если взять любой из результатов, полученных после выполнения декартово произведения, то станет понятно, что актуальными записями являются лишь очень немногие. Поэтому операция декартово произведения является лишь промежуточным этапом.

**Эквисоединение таблиц**

Актуальные строки можно отобрать из декартового произведения путем ввода в запрос параметра WHERE, в котором устанавливается соответствие между полями, посредством которых каждая пара таблиц связана между собой.

Эквисоединение таблиц в предыдущем запросе выглядит следующим образом:

```sql
SELECT student.*, student_hobby.*
FROM student, student_hobby
WHERE student.id = student_hobby.student_id;
```

**Естественное соединение таблиц**

Естественным соединением таблиц называется такое соединение, из которого исключены дубликаты столбцов, по которым проводилось эквисоединение (student.id  и  student_hobby.student_id). Для исключения дубликатов в операторе SELECT необходимо явно указать только один из столбцов этих пар, принадлежащего главной таблице:

```sql
SELECT student.id, student.name, student.surname, student.birth_date, student_hobby.id
FROM student, student_hobby
WHERE student.id = student_hobby.student_id;
```

**Композиция таблиц**

Композицией таблиц называется соединение, из которого полностью исключены столбцы, по которым производилось соединение.

**Соединение таблиц с дополнительным условием**

Наравне с уловными выражениями, предназначенными для указания способа соединения таблиц между собой, в параметре WHERE можно дополнительно указывать все описанные выше дополнительные условия фильтрации, объединенные с условными выражениями соединения при помощи оператора AND. Например:

-- получение информации о студентах из групп 2011,2012,3014 и их хобби

```sql
SELECT  student.id, student.name, student.surname, student.birth_date, student_hobby.id
FROM student, student_hobby
WHERE student.id = student_hobby.student_id  AND student.n_group IN (2011,2012,3014);
```

**Соединение таблицы со своей копией**

В ряде приложений возникает необходимость одновременной обработки данных какой-либо таблицы и одной или нескольких ее копий, создаваемых на время выполнения запроса.

Данная возможность часто используется для выявления объектов, имеющие общие значения атрибутов и находящиеся в одной таблице. В последнем случае в параметре WHERE устанавливают равенство значений всех одноименных столбцов этих таблиц, по значениям которых необходимо выявить совпадения, а для остальных установить неравенство значений (обычно достаточно установить неравенство значений полей, входящих в состав первичного ключа).

Временную копию таблицы можно сформировать, указав имя псевдонима за именем таблицы во фразе FROM.

Пример соединения таблиц со своей копией:

-- получение списка однофамильцев

```sql
SELECT  s1.*
FROM student s1, student s2
WHERE s1.surname=s2.surname AND s1.id<>s2.id;
```

**Внутреннее и внешнее объединение таблиц**

Ранее были рассмотрены способы получения связанных между собой данных, находящихся в нескольких таблицах, при помощи комбинирования операций декартово произведения и горизонтальной фильтрации строк получившегося набора данных.

Кроме этого во многих СУБД существуют реализации операции внутреннего и внешнего условных соединений таблиц внутри одного запроса – INNER  JOIN (внутреннее объединение), LEFT  JOIN (полное левое объединение) и RIGHT  JOIN (полное правое объединение).

Синтаксис применения операция объединения выглядит следующим образом:

```sql
SELECT _список_полей_
FROM _таблица1_ ( INNER | LEFT | RIGHT ) JOIN _таблица2_
ON _таблица1.связующее_поле = таблица2.связующее_поле_;
```

В результате выполнения внутреннего объединения из кортежей двух объединяемых таблиц остаются только те, для которых выполняется указанное условие.

При полном (внешнем) левом объединении из кортежей двух объединяемых таблиц остаются все кортежи таблицы, указанной слева от условного выражения, и кортежи правой таблицы, для которых выполняется указанное условие.

При полном (внешнем) правом объединении из кортежей двух объединяемых таблиц остаются все кортежи таблицы, указанной справа от условного выражения, и кортежи левой таблицы, для которых выполняется указанное условие.

В СУБД ORACLE также для реализации левого внешнего объединения используется оператор (+) в предложении WHERE, который ставиться справа от столбца, по которому осуществляется соединение, справа от знака =. Аналогично для правого объединения оператор (+) ставиться справа от столбца слева от знака равенства.

**Вложенные подзапросы**

**Виды вложенных подзапросов**

Вложенный подзапрос – это оператор SELECT, заключенный в круглые скобки и вложенный в команду языка DML, и использующийся в качестве источника данных для параметров SELECT, FROM, WHERE и HAVING. Каждый подзапрос в свою очередь может содержать в себе подзапрос и т.д. В каждой СУБД существуют ограничения на количество вложенных подзапросов, но обычно этих ограничений хватает, чтобы реализовать задачи любой известной сложности.

Вложенные подзапросы всегда применяются тогда, когда для выполнения основного запроса необходимо использовать данные, находящиеся в той же или других таблицах, которые невозможно получить при помощи соединения таблиц. Например, чтобы определить, какие хобби имеют степень риска, превышающую среднюю  степень риска, необходимо предварительно вычислить эту среднюю степень риска.

Все подзапросы можно условно разделить на _однострочные_ и _многострочные_, а также на _простые_ и _коррелированные_.

Однострочные подзапросы возвращают в качестве результата всегда одну строку, не больше и не меньше, поэтому над результатами выполнения таких запросов можно использовать операции сравнения.

Многострочные запросы в общем случае могут вернуть любое количество строк, поэтому над результатами таких подзапросов нельзя использовать операции сравнения (если один из аргументов операции сравнения будет являться пустым множеством или множеством, состоящим более чем из одного элемента, то запрос завершиться с ошибкой). Для таких подзапросов применимы операторы IN и EXISTS.

Простыми, или независимыми, подзапросами называются вложенные подзапросы, выполнение которых не зависит от внешнего запроса. Простые вложенные подзапросы обрабатываются системой «снизу вверх». Первым обрабатывается вложенный подзапрос самого нижнего уровня. Множество значений, полученное в результате его выполнения, используется при реализации подзапроса более высокого уровня и т.д.

Запросы с коррелированными вложенными подзапросами обрабатываются системой в обратном порядке. Сначала выбирается первая строка рабочей таблицы, сформированной основным запросом, и из нее выбираются значения тех столбцов, которые используются во вложенном подзапросе (вложенных подзапросах). Если эти значения удовлетворяют условиям вложенного подзапроса, то выбранная строка включается в результат. Затем выбирается вторая строка и т.д., пока в результат не будут включены все строки, удовлетворяющие вложенному подзапросу (последовательности вложенных подзапросов).

Следует отметить, что SQL обладает большой избыточностью в том смысле, что он часто предоставляет несколько различных способов формулировки одного и того же запроса. Поэтому во многих примерах данной главы при помощи подзапросов будут решаться задачи, часть из которых успешнее реализуется с помощью соединений, но здесь все же будут приведены их варианты с использованием вложенных подзапросов. Это связано с необходимостью детального знакомства с созданием и принципом выполнения вложенных подзапросов, так как существует немало задач (особенно на удаление и изменение данных), которые не могут быть реализованы другим способом. Кроме того, разные формулировки одного и того же запроса требуют для своего выполнения различных ресурсов памяти и могут значительно отличаться по времени реализации в разных СУБД.

**Однострочные вложенные подзапросы**

Однострочные вложенные подзапросы чаще всего применяются совместно с агрегатными функциями, результат вычисления которых и является единственным результатом подзапроса. Например:

-- получить название хобби, имеющего  максимальную степень риска

```sql
SELECT name 
FROM hobby
WHERE risk = (SELECT Max(risk) FROM student);
```

В данном случае вложенный подзапрос должен выполняться для каждой строки, обрабатываемой во внешнем запросе. Но очевидно, что результат вложенного запроса никоим образом не зависит от того, какая строка обрабатывается во внешнем запросе. В таких случаях, чтобы не выполнять один и тот же вложенный подзапрос, независящий от внешнего запроса, некоторые СУБД кэшируют (запоминают) результат, полученный в результате первого выполнения вложенного подзапроса, и подставляют для всех остальных строк таблиц, обрабатываемых во внешнем запросе.

**Многострочные вложенные подзапросы**

Многострочные вложенные подзапросы используются для представления множества значений, исследование которых должно осуществляться в каком-либо предикате IN, что иллюстрируется в следующем примере:

-- определение номера зачеток студентов, которые не имеют ни одного хобби

```sql
SELECT id FROM student WHERE id NOT IN
(SELECT DISTINCT student_id FROM student_hobby);
```

Иногда с использованием многострочных подзапросов также можно решать задачи, которые обычно решаются простым соединением таблиц внутри одного запроса, например:

-- определить номера зачеток студентов, которые имеют хотя бы одно хобби

```sql
SELECT id FROM student WHERE id IN
(SELECT DISTINCT student_id FROM student_hobby);
```

-- Эту задачу можно решить путем простого соединения таблиц

```sql
SELECT id FROM student, student_hobby
WHERE student.id= student_hobby.student_id ;
```

**Коррелированные вложенные подзапросы**

Коррелированные подзапросы характерны тем, что вложенный подзапрос не может быть обработан прежде, чем будет обрабатываться внешний подзапрос. Это связано с тем, что вложенный подзапрос зависит от значения внешнего запроса, а оно изменяется по мере того, как система проверяет различные строки таблицы, указанной во внешнем запросе. Например:

-- вывести фамилии студентов, названия тех их хобби, которыми каждый из них увлекается дольше всего

```sql
SELECT st.surname, sh.name 
FROM student st, student_hobby sh
WHERE sh.student_id=st.id AND sh.started_at=
(
  SELECT MIN(started_at) 
  FROM student_hobby
  WHERE student_id=st.id
);
```

## SQL injection

[Материал прошлого семестра](https://github.com/RyabovNick/databasecourse_p1/tree/master/Theory/7_SQL_injection)
