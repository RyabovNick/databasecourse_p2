# Triggers

1. Что такое триггер?
2. Зачем он нужен?
3. На какие операторы можно повесить триггер?
4. Время срабатывания триггеры
5. Строчные и операторные триггеры

**Триггер** - это особого вида процедура, которая выполняется автоматически при возникновении некоторого события, указанного в спецификации триггера, - _триггерного события_ (triggering event).

В PL/SQL можно создать триггеры, которые будут срабатывать в одной из следующих ситуаций:

- применение оператора DML (INSERT, UPDATE, DELETE) к определенному объекту схемы;
- применение оператора DDL (CREATE, ALTER, DROP) внутри схемы или базы данных;
- вход пользователя в систему или выход его из системы, ошибка сервера, запуск базы данных или останов базы данных.

Между триггерами и обычными процедурами PL/SQL есть три различия:

- триггеры нельзя вызывать напрямую из кода программы. Oracle вызывает их автоматически в ответ на определенное событие;
- триггеры не имеют списка параметров;
- спецификация триггера немного отличается от спецификации процедуры.

Сходство между триггерами и процедурами состоит в следующем:

- тело триггера выглядит точно также, как и тело процедуры - и то, и другое суть базовые блоки PL/SQL;
- триггер не возвращает никаких значений;
- триггеры можно использовать для выполнения разнообразных задач;
- триггеры используются для реализации сложных бизнес-правил. Например, триггер может проверять, истек ли срок продаваемого товара к моменту осуществления сделки продажи, или нет. Если истек, то триггер может выполнять некоторые автоматические действия по предотвращению продажи данного товара;
- триггеры могут обеспечивать прозрачное протоколирование событий, например, отслеживать сколько раз каждый из пользователей обращался к определенной таблице.

Триггеры представляют собой весьма мощные инструменты. Однако их следует использовать аккуратно, поскольку триггер может срабатывать при каждом обращении к таблице, тем самым увеличивая нагрузку на сервер базы данных. Разумное практическое правило состоит в том, чтобы использовать триггер только для действий, которые нельзя выполнить другими средствами. Например, если есть возможность создать одно или несколько ограничений, выполняющих работу некоторого триггера, следует использовать эти ограничения. Если итоговые величины допустимо вычислять в нерабочее время, систему лучше спроектировать именно так, а не использовать триггеры, срабатывающие при каждой транзакции. Предположим, например, что банк принимает решение о доставке дополнительной наличности из центрального хранилища в зависимости от того, сколько 20-долларовых банкнот было выдано за текущий день. Эту величину можно определять по окончании рабочего дня. Если же для обновления счетчика 20-долларовых банкнот будет использоваться триггер, то его постоянное срабатывание может существенно замедлить скорость выполнения транзакций в рабочие часы.

Триггеры, определенные для таблиц, называются _табличными триггерами_ (table triggers). Далее речь пойдет именно о них. Синтаксис создания триггера имеет следующий вид:

```
CREATE OR REPLACE TRIGGER имя_триггера момент_срабатывания триггерное_событие
ON имя_таблицы_или_представления
[WHEN триггерное_ограничение]
[FOR EACH ROW]
[DECLARE
объявления]
BEGIN
  Операторы
[EXCEPTION
 WHEN имя_исключения THEN …]
END имя_триггера;
```

## Типы триггеров

_Момент срабатывания_ определяет, когда будет срабатывать триггер: до (BEFORE), после (AFTER) и вместо (INSTEAD OF) наступления триггерного события (выполнения запускающего оператора).

Если указано значение BEFORE, триггер выполняется до каких-либо проверок ограничений на строки, затрагиваемые триггерным событием. Никакие строки не блокируются. Триггер этого типа называется, соответственно, _BEFORE-триггером_ (BEFORE trigger).

Если выбрать ключевое слово AFTER, то триггер будет срабатывать после того, как запускающий оператор завершит свою работу и будут выполнены проверки всех ограничений. В этом случае затрагиваемые строки блокируются на время выполнения триггера. Триггер этого типа называется _AFTER-триггером_ (AFTER trigger).

Триггеры INSTEAD OF применяются только для представлений (VIEW). Проблема состоит в том, что операторы DML не применимы к представлениям. Нельзя добавлять, изменять или удалять записи из представлений. Триггеры INSTEAD OF вызываются вместо выполнения DML-выражений. Если вы выполните оператор DML к представлению, то в соответствующем триггере можно выполнить какие-либо действия, и тогда у пользователя создастся впечатление, что он работает с таблицей.

_Триггерное событие_ может принимать значения INSERT, UPDATE или DELETE.

_Триггерное ограничение_ - это одно из дополнительных ограничений, которые должны быть выполнены для срабатывания триггера.

Необязательный набор ключевых слов FOR EACH ROW указывает на необходимость выполнять тело триггера для каждой строки, затрагиваемой запускающим оператором. Такие триггеры называются _строчными_ (row triggers). Если опция FOR EACH ROW отсутствует, то при наступлении триггерного события триггер выполнится только один раз. В этом случае он называется _операторным_ триггером (statement trigger), поскольку выполняется только один раз для каждого запускающего оператора.

Часть кода между DECLARE и END _имя триггера_ представляет собой обычный базовый блок PL/SQL.

Различным триггерные события можно комбинировать с помощью оператора OR. Например:

```
DELETE OR INSERT остальные_операторы
```

В случае использования UPDATE можно указать список столбцов, при изменении которых будет срабатывать триггер:

```
UPDATE OF столбец_1, столбец_2, ...
```

При использовании UPDATE в операторах PL/SQL обращение к новой и старой строкам выполняются с помощью слов "new" и "old", предваренных двоеточием. Так, _:old.имястолбца_ даст значение, которое столбец имел до обновления. Однако в триггерном ограничении имена "old" и "new" используются без двоеточий.

**ВАЖНО!!!** Триггерные ограничения, а также _корреляционные имена_ new и old, могут использоваться только в строчных триггерах.

Корреляционное имя new имеет смысл использовать только в триггерах на INSERT и UPDATE, поскольку в триггерах на DELETE никакого нового значения полей нет. Тоже самое можно сказать и о корреляционном имени old, значение которого определено только для триггеров, сработавших на UPDATE и DELETE.

Одна очень важная особенность корреляционного имени new для _строчных BEFORE-триггеров_: значения полей корреляционного имени new можно менять в строчных BEFORE-триггерах. Например, если в триггере BEFORE INSERT проверяется значение поля добавляемой строки и оно по каким-то соображениям не удовлетворяет необходимым условиям информационной системы, его (значения поля) можно изменить, применив оператор присваивания непосредственно к корреляционному имени new:

```
IF :new.procent>50 then
 :new.procent:=50;
END IF;
```

Если триггер срабатывает сразу на несколько событий, то чтобы определить на какое из указанных событий он сработал, можно внутри исполняемой секции триггера использовать условные предикаты INSERTING, UPDATING и DELETING. Первый из них равен TRUE, когда триггер сработал на INSERT, второй - на UPDATE, третий - на DELETE.

## Пример триггера

Триггер, который будет запрещать изменение имени менеджера (поле NAME).

```
CREATE OR REPLACE TRIGGER onManagersUpdate
BEFORE UPDATE OF name ON Managers
FOR EACH ROW
DECLARE
 cant_change_name EXCEPTION;
BEGIN
 IF :new.name<>:old.name THEN
 RAISE cant_change_name;
 END IF;
EXCEPTION
 WHEN cant_change_name THEN
  dbms_output.put_line('Нельзя изменить имя менеджера');
  :new.name:=:old.name;
END;
```

Данный триггер не позволит изменить значение поля NAME в таблице MANAGERS. При попытке сделать это сработает триггер, внутри которого производится сравнение старого значения и нового значения поля NAME. Если они различаются, то активизируется исключение, при обработке которого на экране появится соответствующее сообщение. В данном случае использована одна очень важная особенность BEFORE-триггеров: если в BEFORE-триггере возникает исключение, то SQL-предложение, вызвавшее триггер, не выполнится.

Удаление триггеров, также как и удаление всех остальных объектов СУБД Oracle, осуществляется посредством оператора DROP:

```
DROP имя_триггера;
```

Если по каким-то причинам триггер нужно на время отключить, то это можно сделать при помощи команды ALTER TRIGGER имя_триггера DISABLE;

Обратное включение триггера осуществляется при помощи команды ALTER TRIGGER имя_триггера ENABLE;

Поскольку с одной таблицей могут быть связаны несколько триггеров, то бывает необходимо отключить сразу все эти триггеры. Это делается при помощи команды ALTER TABLE имя*таблицы DISABLE ALL TRIGGERS;  
Включение всех триггеров осуществляется командой ALTER TABLE имя*таблицы ENABLE ALL TRIGGERS;

## Вывод информации о триггерах

Например, предположим, что для создания триггера REORDER было использовано следующее предложение:

```
CREATE TRIGGER reorder
AFTER UPDATE OF parts_on_hand ON inventory
FOR EACH ROW
WHEN (new.parts_on_hand < new.reorder_point)
DECLARE
x NUMBER;
BEGIN
SELECT COUNT(*) INTO x
FROM pending_orders
WHERE part_no = :new.part_no;
IF x = 0 THEN
INSERT INTO pending_orders
VALUES (:new.part_no, :new.reorder_quantity, sysdate);
END IF;
END;
```

Следующие два запроса возвращают информацию о триггере REORDER:

```
SELECT type, triggering_statement, table_name
FROM user_triggers
WHERE name = 'REORDER';

SELECT trigger_body
FROM user_triggers
WHERE name = 'REORDER';
```
