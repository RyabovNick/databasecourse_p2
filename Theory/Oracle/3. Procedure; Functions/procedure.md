# Procedure

1. Вспоминаем что такое последовательность?
2. Что такое процедура?
3. Зачем применяется?
4. Синтаксис
5. Вызов процедуры
6. Динамические типы

**Процедуры** (или хранимые процедуры) – это определенный набор инструкций, написанных на языке PL/SQL, и операторов DML. Вызов процедуры приводит к выполнению содержащихся в ней инструкций. Процедура хранится в базе данных, поэтому она и называется хранимой.

Процедура – это именованный блок PL/SQL, то есть секция заголовка непустая. Секция заголовка называется еще спецификацией процедуры (procedure specification). Спецификация процедуры включает в себя имя процедуры и описание ее входных и выходных данных. После спецификации идет секция объявления, если это необходимо, выполняемая секция (или тело процедуры) и секция исключений
(опять же необязательная).

## Создание процедуры

Создается процедура при помощи оператора **CREATE PROCEDURE**.
Как правило эту команду пишут **CREATE OR REPLACE PROCEDURE**, что означает "создать или заменить процедуру, если уже есть процедура с таким именем и набором входных параметров". Конечно, перед заменой процедуры можно предварительно удалить ее прежний вариант, но на практике, как правило, используют именно такую конструкцию. Например, оператор создания процедуры, увеличивающей все цены на определенный процент может выглядить так:

```
CREATE OR REPLACE PROCEDURE increase_prices(procent IN NUMBER:=10)
AS
BEGIN
Update pricelist  set price=price+price*procent/100;
END;
```

## Входные и выходные параметры

Между именем входного параметра и его типом можно указывать два специальных слова – **IN** и/или **OUT**. Указание IN будет означать, что в данной переменной процедуре было передано входное значение. Указание OUT означает, то эту переменную можно использовать для возврата какого-то значения. Можно также указывать одновременно IN и OUT. Если ничего не указано, то подразумевается IN.

**Важно:** типы данных в процедуре не могут иметь спецификаций размера. Например, нужно указывать NUMBER, но не NUMBER(10,2).

## Значения по умолчанию

Параметру procent в приведенном выше примере было присвоено значение 10. Это означает, что если при вызове процедуры параметр procent не был указан, то он будет приравнен к 10.
Секция объявлений в процедуре располагается между служебным словом AS и началом выполняемой секции, то есть словом _BEGIN_. Служебное слово DECLARE при этом, в отличие от секции объявлений анонимного блока и секции объявлений в триггере, НЕ УКАЗЫВАЕТСЯ. Например:

```
CREATE OR REPLACE PROCEDURE temp
AS
s varchar(50);
BEGIN
dbms_output.put_line(s);
END;
```

Процедура может содержать только операторы _DML_, управляющие конструкции и вызовы процедур и функций. В процедуре нельзя использовать операторы _DDL_ в число которых входят CREATE, ALTER, DROP.

Начиная с версии 8i в ORACLE появилась возможность обойти это "неудобство" вызовом специальной процедуры IMMEDIATE. Например, внутри базового блока PL/SQL можно написать конструкцию следующего вида:

```
EXECUTE IMMEDIATE 'create table test(id number);'
```

Но для того, чтобы вызвать функцию create table (или какую-либо другую) в качестве параметра, необходимо обладать соответствующей прямой привилегией. Например, чтобы вышеприведенный пример заработал, необходимо, чтобы администратор базы данных выдал вам привилегию _CREATE TABLE_, несмотря на то, что вы уже обладаете ролью _RESOURCE_, в которую входит данная привилегия.

## Вызов процедур

Для вызова процедур используется следующая конструкция:

```
Declare
Begin
increase_prices(5);
end;
```

Если процедуре не передается входной параметр, то при выполнении процедуры он будет равен значению по умолчанию.

Вызов процедуры можно производить не только из среды SQL Plus, но и, естественно, внутри других процедур, функций или триггеров.

## Удаление процедур

Для удаления процедуры необходимо выполнить оператор _DROP PROCEDURE_ имя_процедуры


## Использование курсора в качестве параметра

Oracle предоставляет возможность возвращать не только переменные заданных типов, пользовательских (TYPE, record), но и курсоры.

Для такой ситуации необходимо добавить параметр `p_animset OUT SYS_REFCURSOR`

В исполняемой секции необходимо открыть курсор

```
OPEN p_animset FOR
  SELECT name, weight
  FROM   animals;
```

Процедура готова, она возвращает все имена и вес животных, кладёт это в выходной параметр.

Полный код выглядит так:

```
create or replace PROCEDURE get_animals (p_animset OUT SYS_REFCURSOR) AS 
BEGIN 
  OPEN p_animset FOR
    SELECT name, weight
    FROM   animals;
END;
```

Далее как этот курсор использовать. Создадим ещё одну процедуру из которой можно запустить выше написанную (для удобства,  можно и анонимный блок):

```
create or replace procedure RUN_GET_ANIMALS
AS
l_cursor  SYS_REFCURSOR;
l_name animals.name%TYPE;
l_weight animals.weight%TYPE;
```

Тут объявляем курсор, который будет передан в вашенаписанную процедуру в качестве параметра, а также 2 переменные %TYPE. В данной задаче не получится использовать %rowtype, т.к. курсор пустой в том моменте, где мы объявляем переменные.

```
Begin
get_animals(l_cursor);
LOOP 
    FETCH l_cursor
    INTO  l_name, l_weight;
    EXIT WHEN l_cursor%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(l_name || ' | ' || l_weight);
  END LOOP;
  CLOSE l_cursor;
end;
```

Тут запускаем процедуру, написанную ранее. Курсор уже открыт ранее, поэтому не получится использовать for. Построчно обрабатываем курсор и выводим на экран.






